.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "WordNet::Similarity::PathFinder 3pm"
.TH WordNet::Similarity::PathFinder 3pm "2008-05-23" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
WordNet::Similarity::PathFinder \- module to implement path finding methods
(by node counting) for WordNet::Similarity measures of semantic relatedness
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& use WordNet::QueryData;
\& my $wn = WordNet::QueryData\->new;
\&
\& use WordNet::Similarity::PathFinder;
\& my $obj = WordNet::Similarity::PathFinder\->new ($wn);
\&
\& my $wps1 = \*(Aqwinston_churchill#n#1\*(Aq;
\& my $wps2 = \*(Aqengland#n#1\*(Aq;
\&
\& # parseWps returns reference to an array that contains 
\& # word1 pos1 sense1 offset1 word2 pos2 sense2 offset2
\&
\& my $result = $obj\->parseWps($wps1, $wps2);
\& print "@$result\en";
\&
\& # path is a reference to an array that contains the path between
\& # wps1 and wps2 expressed as a series of wps values
\&
\& my @paths = $obj\->getShortestPath($wps1, $wps2, \*(Aqn\*(Aq, \*(Aqwps\*(Aq);
\& my ($length, $path) = @{shift @paths};
\& defined $path or die "No path between synsets";
\& print "shortest path between $wps1 and $wps2 is $length edges long\en";
\& print "@$path\en";
\&
\& my $offset1 = $wn \-> offset($wps1);
\& my $offset2 = $wn \-> offset($wps2);
\&
\& # path is a reference to an array that contains the path between
\& # offset1 and offset2 expressed as a series of offset values
\&
\& my @paths = $obj\->getShortestPath($offset1, $offset2, \*(Aqn\*(Aq, \*(Aqoffset\*(Aq);
\& my ($length, $path) = @{shift @paths};
\& defined $path or die "No path between synsets";
\& print "shortest path between $offset1 and $offset2 is $length edges  long\en";
\& print "@$path\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Introduction"
.IX Subsection "Introduction"
This class is derived from (i.e., is a sub-class of) WordNet::Similarity.
.PP
The methods in this module are useful for finding paths between concepts
in WordNet's 'is\-a' taxonomies.  Concept A is-a concept B if, and only if,
B is a hypernym of A or A is in the hypernym tree of B.  N.B., only nouns
and verbs have hypernyms.
.PP
The methods that find path lengths (such as \f(CW\*(C`getShortestPath()\*(C'\fR and
\&\f(CW\*(C`getAllPaths()\*(C'\fR compute the lengths using node-counting not edge-counting.
In general, the length of a path using node-counting will always be one
more than the length using edge-counting.  For example, if concept A
is a hyponym of concept B, then the path length between A and B using
node-counting is 2, but the length using edge-counting is 1.  Likewise, the
path between A and A is 1 using node-counting and 0 using edge-counting.
.SS "Methods"
.IX Subsection "Methods"
This module inherits all the methods of WordNet::Similarity.  Additionally,
the following methods are also defined.
.PP
\fIPublic methods\fR
.IX Subsection "Public methods"
.ie n .IP "$measure\->\fIsetPosList()\fR" 4
.el .IP "\f(CW$measure\fR\->\fIsetPosList()\fR" 4
.IX Item "$measure->setPosList()"
Specifies the parts of speech that measures derived from this module
support (namely, nouns and verbs).
.Sp
parameters: none
.Sp
returns: true
.ie n .IP "$self\->\fItraceOptions()\fR" 4
.el .IP "\f(CW$self\fR\->\fItraceOptions()\fR" 4
.IX Item "$self->traceOptions()"
Overrides method of same name in WordNet::Similarity.  Prints module-specific
configuration options to the trace string (if tracing is on).  PathFinder
supports one module specific option: rootNode.
.Sp
Parameters: none
.Sp
returns: nothing
.ie n .IP "$measure\->parseWps($synset1, $synset2)" 4
.el .IP "\f(CW$measure\fR\->parseWps($synset1, \f(CW$synset2\fR)" 4
.IX Item "$measure->parseWps($synset1, $synset2)"
parameters: synset1, synset2 \*(-- two synsets in wps format
.Sp
returns: a reference to an array, WordNet::Similarity::UNRELATED, or undef
.Sp
Overrides the \fIparseWps()\fR method in WordNet::Similarity in order to run
additional checks, but calls \fIWordNet::Similarity::parseWps()\fR to get
those checks accomplished as well.  Thus, this method does everything
that WordNet::Similarity::parseWps does.
.RS 4
.IP "quote from WordNet::Similarity::parseWps:" 4
.IX Item "quote from WordNet::Similarity::parseWps:"
This method checks the format of the two input synsets by calling
\&\fIvalidateSynset()\fR for each synset.
.Sp
If the synsets are in wps format, a reference to an array will be returned.
This array has the form [$word1, \f(CW$pos1\fR, \f(CW$sense1\fR, \f(CW$offset1\fR, \f(CW$word2\fR, \f(CW$pos2\fR,
\&\f(CW$sense2\fR, \f(CW$offset2\fR] where \f(CW$word1\fR is the word part of \f(CW$wps1\fR, \f(CW$pos1\fR, is the
part of speech of \f(CW$wps1\fR, \f(CW$sense1\fR is the sense from \f(CW$wps\fR.  \f(CW$offset1\fR is the
offset for \f(CW$wps1\fR.
.Sp
If an error occurs (such as a synset being poorly-formed), then undef
is returned, the error level is set to non-zero, and an error message is
appended to the error string.
.RE
.RS 4
.Sp
In addition, if the two synsets are from different parts of speech, then
WordNet::Similarity::UNRELATED is returned, the error level is set to 1, and
a message is appended to the error string.
.Sp
If either synset is not a noun or a verb, then the error level
is set to 1, a message is appended to the error string, and undef
is returned.
.Sp
If the synsets are in wps format, a reference to an array will be returned.
This array has the form [$word1, \f(CW$pos1\fR, \f(CW$sense1\fR, \f(CW$offset1\fR, \f(CW$word2\fR, \f(CW$pos2\fR,
\&\f(CW$sense2\fR, \f(CW$offset2\fR].
.RE
.ie n .IP "$measure\->getShortestPath($synset1, $synset2, $pos, $mode)" 4
.el .IP "\f(CW$measure\fR\->getShortestPath($synset1, \f(CW$synset2\fR, \f(CW$pos\fR, \f(CW$mode\fR)" 4
.IX Item "$measure->getShortestPath($synset1, $synset2, $pos, $mode)"
Given two input synsets, returns the shortest path between the two synsets.
.Sp
Parameters: two synsets, a part-of-speech, and a mode indicator
(i.e., the string 'offset' or 'wps').  If the mode is 'offset', then the
synsets should be WordNet offsets.  If the mode is 'wps', then the synsets
should be in word#pos#sense format.
.Sp
Returns: a list of references to arrays.  Each array has the form
\&\f(CW\*(C`($path_length, $path_ref)\*(C'\fR where \f(CW$path_ref\fR is
a reference to an array whose elements are the synsets along the shortest
path between the two input synsets.  There will be as many array references
returned as there are shortest paths between the synsets.  That is, there
will be no arrays returned if there is no path between the synsets, and there
will be at least one array returned if there is a path between the synsets.
If there are multiple paths tied for being shortest in length, then all
those paths are returned (hence, this is why multiple array references
can be returned).
.Sp
Upon error, returns undef, sets the error level to non-zero, and appends
a message to the error string.
.ie n .IP "$measure\->getAllPaths($synset1, $synset2, $pos, $mode)" 4
.el .IP "\f(CW$measure\fR\->getAllPaths($synset1, \f(CW$synset2\fR, \f(CW$pos\fR, \f(CW$mode\fR)" 4
.IX Item "$measure->getAllPaths($synset1, $synset2, $pos, $mode)"
Given two input synsets, returns all the paths between the two synsets.
.Sp
Parameters: a reference to the object, two synsets, a part-of-speech, and
a mode indicator (the string 'offset' or 'wps').
.Sp
If the mode is 'offset', then the synsets should be WordNet offsets.  If the
mode is 'wps', then they should be strings in word#pos#sense format.
.Sp
Returns: A list of all paths, sorted by path length in ascending order.  The
format for each item in the list is a reference to an array that has the
format: [$top, \f(CW$length\fR, [@synsets_list]] where \f(CW@synset_list\fR is a list
of synsets along the path (including the two input synsets)
.Sp
Returns undef on error.
.ie n .IP "$measure\->validateSynset($synset)" 4
.el .IP "\f(CW$measure\fR\->validateSynset($synset)" 4
.IX Item "$measure->validateSynset($synset)"
parameters: synset \*(-- a string in word#pos#sense format
.Sp
returns: a list or undef on error
.Sp
This method overrides the method of the same name in WordNet::Similarity
to provide additional behavior but calls WordNet::Similarity::validateSynset
to accomplish that method's behavior.  Thus, this method does everything
that WordNet::Similarity::validateSynset does.
.RS 4
.IP "quote from WordNet::Similarity::validateSynset:" 4
.IX Item "quote from WordNet::Similarity::validateSynset:"
This method does the following:
.RS 4
.IP "1." 4
Verifies that the synset is well-formed (i.e., that it consists of three
parts separated by #s, the pos is one of {n, v, a, r} and that sense
is a natural number).  A synset that matches the pattern '[^\e#]+\e#[nvar]\e#\ed+'
is considered well-formed.
.IP "2." 4
Checks if the synset exists by trying to find the offset for the synset
.RE
.RS 4
.RE
.RE
.RS 4
.Sp
This method, however, has a slightly different return value.  Instead of
merely breaking the synset into three parts, it returns the \*(L"safe\*(R" form
of the synset.  That is, if a synset has multiple word senses, this
method returns the first word sense in that synset (this is so that
other path-finding methods work properly).  For example, if the input
to this method is auto#n#1, the return value is ('car', 'n', 1, 2853224)
since the sense 'car#n#1' is the first member of the synset to which
\&'auto#n#1' belongs.
.Sp
If any of these tests fails, then the error level is set to non-zero, a
message is appended to the error string, and undef is returned.
.RE
.PP
\fIPrivate methods\fR
.IX Subsection "Private methods"
.ie n .IP "$measure\->_getHypernymTrees($synset, $pos, $mode)" 4
.el .IP "\f(CW$measure\fR\->_getHypernymTrees($synset, \f(CW$pos\fR, \f(CW$mode\fR)" 4
.IX Item "$measure->_getHypernymTrees($synset, $pos, $mode)"
This method takes as input a synset and returns a list of references
to arrays where these arrays are paths from the input synset to the
top of the taxonomy (*Root*#[nv]#1 if the root node is on).
.Sp
Parameters: a synset, a part-of-speech, and a mode.
The mode must be either the string 'wps' or 'offset'.  If
the mode is 'wps', then the synset must be in wps format; otherwise, it
must be an offset.
.Sp
Returns: a list of references to arrays.  These arrays are paths (hypernym
trees).
.ie n .IP "getLCSbyPath($synset1, $synset2, $pos, $mode)" 4
.el .IP "getLCSbyPath($synset1, \f(CW$synset2\fR, \f(CW$pos\fR, \f(CW$mode\fR)" 4
.IX Item "getLCSbyPath($synset1, $synset2, $pos, $mode)"
Given two input synsets, finds the least common subsumer (\s-1LCS\s0) of them.
If there are multiple candidates for the \s-1LCS\s0 (due to multiple inheritance),
the \s-1LCS\s0 that results in the shortest path between in input concepts is
chosen.
.Sp
Parameters: two synsets, a part of speech, and a mode.
.Sp
Returns: a list of references to arrays where each array has the from
\&\f(CW\*(C`($lcs, $pathlength)\*(C'\fR.  \f(CW$pathlength\fR is the length
of the path between the two input concepts.  There can be multiple LCSs
returned if there are ties for the shortest path between the two synsets.
Returns undef on error.
.ie n .IP "$measure\->_getSubsumerFromTrees($treeref1, $treeref2, $mode)" 4
.el .IP "\f(CW$measure\fR\->_getSubsumerFromTrees($treeref1, \f(CW$treeref2\fR, \f(CW$mode\fR)" 4
.IX Item "$measure->_getSubsumerFromTrees($treeref1, $treeref2, $mode)"
This subroutine returns takes two trees as produced by getHypernymTrees
and returns the most specific subsumer from them.
.Sp
Parameters: two references to arrays, and
a string indicating mode ('wps' or 'offset').
.Sp
Returns: the subsumer or undef
.IP "\fIgetDepth()\fR" 4
.IX Item "getDepth()"
This method is non-functional and likely to be moved to a different module
soon.
.SS "Discussion"
.IX Subsection "Discussion"
Many of the methods in this module can work with either offsets or
wps strings internally.  There are several interesting consequences
of each mode.
.IP "1." 4
An offset is not a unique identifier for a synset, but neither is
a wps string.  An offset only indicates a byte offset in one of the
WordNet data files (data.noun, data.verb, etc. on Unix-like systems).
An offset along with a part of speech, however, does uniquely identify
a synset.
.Sp
A word#pos#sense string, on the other hand, is the opposite extreme.
A word#pos#sense string is an identifier for a unique word sense.  A
synset can have several word senses in it (i.e., a synset is a set
of word senses that are synonymous).  The synset {beer_mug#n#1, stein#n#1}
has two word senses.  The wps strings 'beer_mug#n#1' and 'stein#n#1' can
both be used to refer to the synset.  For simplicity, we usually just
use the first wps string when referring to the synset.  N.B., the
wps representation was developed by WordNet::QueryData.
.IP "2." 4
Early versions of WordNet::Similarity::* used offsets internally for
finding paths, hypernym trees, subsumers, etc.  The module WordNet::QueryData
that is used by Similarity, however, accepts only wps strings as input
to its querySense method, which is used to find hypernyms.  We have found
that it is more efficient (faster) to use wps strings internally.
.SH "AUTHORS"
.IX Header "AUTHORS"
.Vb 2
\& Ted Pedersen, University of Minnesota Duluth
\& tpederse at d.umn.edu
\&
\& Jason Michelizzi, University of Minnesota Duluth
\& mich0212 at d.umn.edu
\&
\& Siddharth Patwardhan, University of Utah, Salt Lake City
\& sidd at cs.utah.edu
.Ve
.SH "BUGS"
.IX Header "BUGS"
None.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIWordNet::Similarity\fR\|(3)
\&\fIWordNet::Similarity::path\fR\|(3)
\&\fIWordNet::Similarity::lch\fR\|(3)
\&\fIWordNet::Similarity::wup\fR\|(3)
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2005, Ted Pedersen, Siddharth Patwardhan and Jason Michelizzi
.PP
This program is free software; you can redistribute it and/or modify it
under the terms of the \s-1GNU\s0 General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version.
.PP
This program is distributed in the hope that it will be useful, but
\&\s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of \s-1MERCHANTABILITY\s0
or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.  See the \s-1GNU\s0 General Public License
for more details.
.PP
You should have received a copy of the \s-1GNU\s0 General Public License along
with this program; if not, write to
.PP
.Vb 3
\&    The Free Software Foundation, Inc.,
\&    59 Temple Place \- Suite 330,
\&    Boston, MA  02111\-1307, USA.
.Ve
.PP
Note: a copy of the \s-1GNU\s0 General Public License is available on the web
at <http://www.gnu.org/licenses/gpl.txt> and is included in this
distribution as \s-1GPL\s0.txt.
